Object.defineProperty(exports, '__esModule', { value: true });

var schema = require('@llamaindex/core/schema');
var vectorStore = require('@llamaindex/core/vector-store');
var chromadb = require('chromadb');

const DEFAULT_TEXT_KEY = "text";
class ChromaVectorStore extends vectorStore.BaseVectorStore {
    constructor(init){
        super(init), this.storesText = true, this.flatMetadata = true, this.collection = null;
        this.collectionName = init.collectionName;
        this.chromaClient = new chromadb.ChromaClient(init.chromaClientParams);
        this.textKey = init.textKey ?? DEFAULT_TEXT_KEY;
    }
    client() {
        return this.chromaClient;
    }
    async getCollection() {
        if (!this.collection) {
            const coll = await this.chromaClient.getOrCreateCollection({
                name: this.collectionName
            });
            this.collection = coll;
        }
        return this.collection;
    }
    getDataToInsert(nodes) {
        const metadatas = nodes.map((node)=>vectorStore.nodeToMetadata(node, true, this.textKey, this.flatMetadata));
        return {
            embeddings: nodes.map((node)=>node.getEmbedding()),
            ids: nodes.map((node)=>node.id_),
            metadatas,
            documents: nodes.map((node)=>node.getContent(schema.MetadataMode.NONE))
        };
    }
    async add(nodes) {
        if (!nodes || nodes.length === 0) {
            return [];
        }
        const dataToInsert = this.getDataToInsert(nodes);
        const collection = await this.getCollection();
        await collection.add(dataToInsert);
        return nodes.map((node)=>node.id_);
    }
    async delete(refDocId, deleteOptions) {
        const collection = await this.getCollection();
        await collection.delete({
            ids: [
                refDocId
            ],
            where: deleteOptions?.where,
            whereDocument: deleteOptions?.whereDocument
        });
    }
    transformChromaFilterCondition(condition) {
        switch(condition){
            case vectorStore.FilterCondition.AND:
                return "$and";
            case vectorStore.FilterCondition.OR:
                return "$or";
            default:
                throw new Error(`Filter condition ${condition} not supported`);
        }
    }
    transformChromaFilterOperator(operator) {
        switch(operator){
            case vectorStore.FilterOperator.EQ:
                return "$eq";
            case vectorStore.FilterOperator.NE:
                return "$ne";
            case vectorStore.FilterOperator.GT:
                return "$gt";
            case vectorStore.FilterOperator.LT:
                return "$lt";
            case vectorStore.FilterOperator.GTE:
                return "$gte";
            case vectorStore.FilterOperator.LTE:
                return "$lte";
            case vectorStore.FilterOperator.IN:
                return "$in";
            case vectorStore.FilterOperator.NIN:
                return "$nin";
            default:
                throw new Error(`Filter operator ${operator} not supported`);
        }
    }
    toChromaFilter(filters) {
        const chromaFilter = {};
        const filtersList = [];
        const condition = filters.condition ? this.transformChromaFilterCondition(filters.condition) : "$and";
        if (filters.filters) {
            for (const filter of filters.filters){
                if (filter.operator) {
                    filtersList.push({
                        [filter.key]: {
                            [this.transformChromaFilterOperator(filter.operator)]: filter.value
                        }
                    });
                } else {
                    filtersList.push({
                        [filter.key]: filter.value
                    });
                }
            }
            if (filtersList.length === 1) {
                return filtersList[0];
            } else if (filtersList.length > 1) {
                chromaFilter[condition] = filtersList;
            }
        }
        return chromaFilter;
    }
    async query(query, options) {
        if (query.docIds) {
            throw new Error("ChromaDB does not support querying by docIDs");
        }
        if (query.mode != vectorStore.VectorStoreQueryMode.DEFAULT) {
            throw new Error("ChromaDB does not support querying by mode");
        }
        let chromaWhere = {};
        if (query.filters) {
            chromaWhere = this.toChromaFilter(query.filters);
        }
        const collection = await this.getCollection();
        const queryResponse = await collection.query({
            queryEmbeddings: query.queryEmbedding ?? undefined,
            nResults: query.similarityTopK,
            where: Object.keys(chromaWhere).length ? chromaWhere : undefined,
            whereDocument: options?.whereDocument,
            //ChromaDB doesn't return the result embeddings by default so we need to include them
            include: [
                "distances",
                "metadatas",
                "documents",
                "embeddings"
            ]
        });
        const vectorStoreQueryResult = {
            nodes: queryResponse.ids[0].map((id, index)=>{
                const text = queryResponse.documents[0][index];
                const metaData = queryResponse.metadatas[0][index] ?? {};
                const node = vectorStore.metadataDictToNode(metaData);
                node.setContent(text);
                return node;
            }),
            similarities: queryResponse.distances[0].map((distance)=>1 - distance),
            ids: queryResponse.ids[0]
        };
        return vectorStoreQueryResult;
    }
}

exports.ChromaVectorStore = ChromaVectorStore;
